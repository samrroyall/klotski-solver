{"version":3,"sources":["solver.ts","App.js","index.js"],"names":["Dir","oppositeDir","dir","Left","Right","Up","Down","oppositeDirs","dirs","numDirs","length","res","Array","i","cloneBlock","block","rowPos","colPos","numRows","numCols","moveBlock","Board","blocks_","winningRow_","winningCol_","_cells","blocks","winningCol","winningRow","this","insertBlocks","fourBlock","Error","j","left","right","up","down","row","col","push","initRowPos","initColPos","stack","currentDirs","initDir","top","pop","undefined","makeMove","nextDir","newDirs","findMoves","newBlock","numNulls","toString","winningBlock","cloneBoard","board","move","b1","b2","TreeNode","board_","parent_","parent","headDist","hashes","children","getMoves","childBoard","childHash","getHash","has","add","child","Solver","head","tail","Set","queue","shift","isSolved","getChildren","node","BoardBlock","props","fourblock","className","twoblockV","twoblockH","oneblock","size","alert","BoardCell","click","e","onClickFunc","currentTarget","id","underblock","hasOwnProperty","currRow","parseInt","split","currCol","winRow","winCol","winCell","onMouseUp","onDropFunc","clickableWinCell","onClick","cell","clickableCell","key","BoardRow","cells","map","val","state","blocksAdded","onDrop","bind","dragBlock","lastRow","lastCol","newBlocks","setState","onAddBlock","NoBlock","tempRow","tempCell","b","r","c","getBlocks","React","Component","DraggableBlock","rel","pos","drop","button","currPos","getBoundingClientRect","document","addEventListener","onDragFunc","stopPropagation","preventDefault","x","pageX","y","pageY","removeEventListener","steez","position","classString","style","onMouseDown","Toolbar","show","Buttons","clearButton","onClear","doubleClearButton","onDoubleClear","defaultButton","onDefault","finishButton","onFinish","nextButton","onNext","prevButton","onPrev","solveButton","onSolve","finished","solved","cleared","Content","default","displayText","clear","clearDragBlock","doubleClear","dragBlockInfo","finish","next","prev","restart","setWinningPos","solve","clearFunc","setTimeout","s","solutionMoves","getBoards","numMoves","boards","boardIdx","err","n","callFunction","repeater","setInterval","clearInterval","initialBlocks","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.b87d1fa3.chunk.js","sourcesContent":["enum Dir { Left, Right, Up, Down }\n\nfunction oppositeDir(dir: Dir): Dir {\n    // for a given direction, return its opposites\n    if (dir === Dir.Left) return Dir.Right;\n    else if (dir === Dir.Right) return Dir.Left;\n    else if (dir === Dir.Up) return Dir.Down;\n    else return Dir.Up;\n}\n\nfunction oppositeDirs(dirs: Array<Dir>): Array<Dir> {\n    // for a list of directions, return a reversed list of the opposites \n    // of these directions\n    let numDirs: number = dirs.length;\n    let res: Array<Dir> = new Array<Dir>(numDirs);\n    for (let i: number = 0; i < numDirs; i++) {\n        res[numDirs-i-1] = oppositeDir(dirs[i]);\n    }\n    return res;\n}\n\ninterface Block {\n    readonly numRows: number;\n    readonly numCols: number;\n    rowPos: number;\n    colPos: number;\n}\n\nfunction cloneBlock(block: Block): Block {\n    return ({\n        rowPos: block.rowPos,\n        colPos: block.colPos,\n        numRows: block.numRows,\n        numCols: block.numCols\n    });\n}\n\ninterface Move {\n    readonly block: Block;\n    readonly dirs: Array<Dir>;\n}\n\n\nfunction moveBlock(block: Block, dirs: Array<Dir>): void {\n    // for each direction in a direction list, update the block \n    // positioning accordingly\n    for (let dir of dirs) {\n        if (dir === Dir.Left) block.colPos--;\n        else if (dir === Dir.Right) block.colPos++;\n        else if (dir === Dir.Up) block.rowPos--;\n        else block.rowPos++;\n    }\n    return;\n}\n\nfunction equivalentBlocks(b1: Block, b2: Block): boolean {\n    // return a boolean value representing whether two blocks are equivalent\n    return (\n      b1.rowPos === b2.rowPos && \n      b1.colPos === b2.colPos &&\n      b1.numRows === b2.numRows && \n      b1.numCols === b2.numCols\n    );\n}\n\n\nclass Board {\n    // ATTRIBUTES\n    private _cells: Array<Array<Block | null>> = [\n        [null, null, null, null],\n        [null, null, null, null],\n        [null, null, null, null],\n        [null, null, null, null],\n        [null, null, null, null],\n    ];\n    readonly blocks: Array<Block>;\n    readonly winningCol: number; \n    readonly winningRow: number; \n\n    // METHODS\n    private insertBlocks(): void {\n        // for each block, ensure that all board cells to be covered by the \n        // block are free; if so, place `block` in all covered cells.\n        let fourBlock: boolean = false;\n        for (let block of this.blocks) {\n            if (block.numRows*block.numCols === 4 && !fourBlock) fourBlock = true; \n            else if (block.numRows*block.numCols === 4) throw new Error(\"There must be exacly one block of size 4\");\n            for (let i: number = block.rowPos; i < block.rowPos + block.numRows; i++) {\n                for (let j: number = block.colPos; j < block.colPos + block.numCols; j++) {\n                    if (this._cells[i][j] === null) {\n                        this._cells[i][j] = block;\n                    } else {\n                        throw new Error(\"Invalid block positioning\");\n                    }\n                }\n            }\n        }\n        if (!fourBlock) throw new Error(\"There must be exactly one block of size 4\");\n    }\n    private currentDirs(block: Block): Array<Dir> {\n        // for a given block return a list of directions corresponding \n        // to open moves\n        let dirs: Array<Dir> = new Array<Dir>();\n        let left: boolean = true;\n        let right: boolean = true;\n        let up: boolean = true;\n        let down: boolean = true;\n        // check horizontal moves\n        for (let row: number = block.rowPos; row < block.rowPos + block.numRows; row++) {\n            // Left\n            let col: number = block.colPos;\n            if (left && (col < 1 || this._cells[row][col-1] !== null)) left = false;\n            // Right\n            col = block.colPos + block.numCols - 1;\n            if (right && (col > 2 || this._cells[row][col+1] !== null)) right = false;\n        }\n        // check vertical moves\n        for (let col: number = block.colPos; col < block.colPos + block.numCols; col++) {\n            // Up\n            let row: number = block.rowPos;\n            if (up && (row < 1 || this._cells[row-1][col] !== null)) up = false;\n            // Down\n            row = block.rowPos + block.numRows - 1;\n            if (down && (row > 3 || this._cells[row+1][col] !== null)) down = false;\n        }\n        // Push valid directions to result list\n        if (left) dirs.push(Dir.Left);\n        if (right) dirs.push(Dir.Right);\n        if (up) dirs.push(Dir.Up);\n        if (down) dirs.push(Dir.Down);\n        return dirs;\n    }\n    private makeMove(block: Block, dirs: Array<Dir>): void {\n        // for each direction in a given list of directions and a block, \n        // move the block and update the `_cells` matrix\n        let numRows: number = block.numRows;\n        let numCols: number = block.numCols;\n        for (let dir of dirs) {\n            let initRowPos: number = block.rowPos;\n            let initColPos: number = block.colPos;\n            moveBlock(block, [dir]); // update block positions\n            // update `_cells` for left or up moves\n            if (dir === Dir.Left|| dir === Dir.Up) {\n                for (let i: number = initRowPos; i < initRowPos + numRows; i++) {\n                    for (let j: number = initColPos; j < initColPos + numCols; j++) {\n                        if (dir === Dir.Left) this._cells[i][j-1] = block;\n                        else this._cells[i-1][j] = block;\n                        this._cells[i][j] = null;\n                    }\n                }\n            // update `_cells` for right or down moves\n            } else {\n                for (let i: number = initRowPos + numRows - 1; i >= initRowPos; i--) {\n                    for (let j: number = initColPos + numCols - 1; j >= initColPos; j--) {\n                        if (dir === Dir.Right) this._cells[i][j+1] = block;\n                        else this._cells[i+1][j] = block;\n                        this._cells[i][j] = null;\n                    }\n                }\n\n            }\n        }\n    }\n    private findMoves(block: Block): Array<Array<Dir>> {\n        // given a block, do a depth first search for each available direction\n        // that is not a step backward and return a list of the valid direction paths\n        let res: Array<Array<Dir>> = new Array<Array<Dir>>();\n        let stack: Array<Array<Dir>> = new Array<Array<Dir>>();\n        // push initial directions to stack\n        for (let initDir of this.currentDirs(block)) stack.push([initDir]);\n        while (stack.length > 0) {\n            let top: Array<Dir> | undefined = stack.pop(); // get top\n            if (top !== undefined) {\n                res.push(top); // push dirs to result\n                this.makeMove(block, top); // move block\n                // return valid directions from current position\n                // since a board will have two free spaces, move paths\n                // can be maximum length 2\n                if (top.length < 2) {\n                    for (let nextDir of this.currentDirs(block)) {\n                        // ensure next direction is not a move backward\n                        if (nextDir !== oppositeDir(top[top.length-1])) {\n                            let newDirs: Array<Dir> = [...top];\n                            newDirs.push(nextDir);\n                            stack.push(newDirs); // push new dirs list\n                        }\n                    }\n                }\n                this.makeMove(block, oppositeDirs(top)); // unMove block\n            }\n        }\n        return res;\n    }\n    getMoves(): Array<Move> {\n        // for each block, find all valid move paths and push\n        // the corresponding Move objects to the `moves` array\n        let res: Array<Move> = new Array<Move>();\n        for (let block of this.blocks) {\n            for (let dirs of this.findMoves(block)) {\n                // clone move block\n                let newBlock: Block = cloneBlock(block);\n                // add move to result list\n                res.push({\n                    block: newBlock, \n                    dirs: dirs\n                });\n            }\n        }\n        return res;\n    }\n    getHash(): string {\n        // walk through `_cells` matrix, convert blocks to simple strings, and\n        // concatenate them into the `hash` string\n        let res: string = \"\";\n        let numNulls: number = 0;\n        for (let i: number = 0; i < 5; i++) {\n            for (let j: number  = 0; j < 4; j++) {\n                let block: Block | null = this._cells[i][j];\n                if (block === null) {\n                    res += \"0\";\n                    numNulls++;\n                } else if ( block.numRows*block.numCols === 2) {\n                    res += (block.numRows === 1 ? \"2H\" : \"2V\");\n                } else {\n                    res += (block.numRows*block.numCols).toString();\n                } \n            }\n        }\n        if (numNulls !== 2) throw new Error(\"There must be exactly 2 free spaces on the board\");\n        return res;\n    }\n    isSolved(): boolean {\n        let winningBlock: Block | null = this._cells[this.winningRow][this.winningCol];\n        if (winningBlock !== null) {\n            return (\n                winningBlock.rowPos === this.winningRow && \n                winningBlock.colPos === this.winningCol &&\n                winningBlock.numRows*winningBlock.numCols === 4\n            );\n        }\n        return false;\n    }\n\n    // CONSTRUCTOR \n    constructor(blocks_: Array<Block>, winningRow_: number, winningCol_: number) {\n        this.winningRow = winningRow_;\n        this.winningCol = winningCol_;\n        this.blocks = blocks_;\n        this.insertBlocks();\n    }\n}\n\n\nfunction cloneBoard(board: Board, move: Move): Board {\n    // function to generate a new board following a move\n    let blocks: Array<Block> = new Array<Block>();\n    for (let block of board.blocks) {\n        let newBlock: Block = cloneBlock(block);\n        if (equivalentBlocks(newBlock, move.block)) {\n            moveBlock(newBlock, move.dirs);\n        }\n        blocks.push(newBlock);\n    }\n    let newBoard: Board = new Board(blocks, board.winningRow, board.winningCol);\n    return newBoard;\n}\n\n\nclass TreeNode {\n    // ATTRIBUTES\n    readonly board: Board;\n    readonly parent: TreeNode | null;\n    readonly headDist: number = 0;\n\n    // METHODS\n    getChildren(hashes: Set<string>): Array<TreeNode> {\n        let children: Array<TreeNode> = new Array<TreeNode>();\n        for (let move of this.board.getMoves()) {\n            let childBoard: Board = cloneBoard(this.board, move);\n            let childHash: string = childBoard.getHash();\n            if (!hashes.has(childHash)) {\n                hashes.add(childHash);\n                let child: TreeNode = new TreeNode(childBoard, this);\n                children.push(child);\n            }\n        }\n        return children;\n    }\n\n    // CONSTRUCTOR\n    constructor(board_: Board, parent_: TreeNode | null) {\n        this.board = board_;\n        this.parent = parent_;\n        if (this.parent !== null) this.headDist = this.parent.headDist + 1;\n    }\n}\n\n\nclass Solver {\n    // ATTRIBUTES\n    head: TreeNode;\n    tail: TreeNode | null = null;\n\n    // METHODS\n    solve(): void {\n        // TO-DO\n        let hashes: Set<string> = new Set<string>();\n        let queue: Array<TreeNode> = new Array<TreeNode>();\n        queue.push(this.head); // add the head node to queue\n        hashes.add(this.head.board.getHash()); // add the head node board hash to set\n        // BFS board configurations until a winning board is found\n        while (queue.length > 0) {\n            let top: TreeNode | undefined = queue.shift();\n            if (top !== undefined) {\n                if (top.board.isSolved()) {\n                    this.tail = top;\n                    return;\n                }\n                for (let child of top.getChildren(hashes)) queue.push(child);\n            }\n        }\n        return;\n    }\n    getBoards(): Array<Array<Block>> {\n        if (this.tail === null) {\n            return [];\n        } else {\n            let res: Array<Array<Block>> = new Array<Array<Block>>(this.tail.headDist);\n            let node: TreeNode | null = this.tail;\n            while (node !== null) {\n                res[node.headDist-1] = node.board.blocks;\n                node = node.parent;\n            }\n            return res;\n        }\n    }\n    // CONSTRUCTOR\n    constructor(blocks: Array<Block>, winningRow: number, winningCol: number) {\n        this.head = new TreeNode(new Board(blocks, winningRow, winningCol), null);\n    }\n}\n\nexport default Solver;","import React from 'react';\nimport Solver from './solver.ts';\nimport './style.css';\n\nfunction BoardBlock(props) {\n  const fourblock = <div className=\"col-6 fourblock m-0 bg-danger border border-dark rounded\"></div>;\n  const twoblockV = <div className=\"col-3 twoblockV m-0 bg-primary border border-dark rounded\"></div>;\n  const twoblockH = <div className=\"col-6 twoblockH m-0 bg-warning border border-dark rounded\"></div>;\n  const oneblock = <div className=\"col-3 oneblock m-0 bg-success border border-dark rounded\"></div>;\n  if (props.size === 4) return fourblock;\n  else if (props.size === 2 && props.block.numCols === 1) return twoblockV;\n  else if (props.size === 2) return twoblockH;\n  else if (props.size === 1) return oneblock;\n  else alert(\"Invalid board cell properties\");\n}\n\nfunction BoardCell (props) {\n  // function for calling parent setWinningPos function\n  function click(e) {\n    props.onClickFunc(e.currentTarget.id);\n  }\n  \n  // currently under placed block\n  if (props.block == null) return <span></span>;\n\n  // return placeholder block in next row under block overflow\n  const underblock = <div className=\"col-3 p-0 m-0\"></div>;\n  if (!props.block.hasOwnProperty(\"colPos\")) return underblock;\n\n  const currRow = parseInt(props.id.split(\",\")[0]);\n  const currCol = parseInt(props.id.split(\",\")[1]);\n  const size = props.block.numRows*props.block.numCols;\n  // empty space\n  if (size === 0) {\n    // winning cell vars\n    let winRow = props.winningRow;\n    let winCol = props.winningCol;\n    const winCell = (\n      <div className=\"col-3 boardcell winningcell p-0 m-0 border\"\n        id={props.id}\n        onMouseUp={props.onDropFunc}>\n      </div>\n    );\n    const clickableWinCell = (\n      <div className=\"col-3 boardcell winningcell p-0 m-0 border\"\n        id={props.id}\n        onMouseUp={props.onDropFunc}\n        onClick={click}>\n\n      </div>\n    );\n    // normal cell vars\n    const cell = (\n      <div className=\"col-3 boardcell p-0 m-0 border\"\n        id={props.id}\n        onMouseUp={props.onDropFunc}>\n      </div>\n    );\n    const clickableCell = (\n      <div className=\"col-3 boardcell p-0 m-0 border\"\n        id={props.id}\n        onMouseUp={props.onDropFunc}\n        onClick={click}>\n      </div>\n    );\n    // winning cell\n    if ((currRow === winRow || currRow === winRow+1) && (currCol === winCol || currCol === winCol+1)) {\n      if (currRow === 4 || currCol === 3) return winCell;\n      else return clickableWinCell;\n    // normal cell\n    } else {\n      if (currRow === 4 || currCol === 3) return cell;\n      else return clickableCell;\n    }\n  // block placed\n  } else {\n    return (\n      <BoardBlock\n        key={props.id}\n        size={size}\n        block={props.block}\n      />\n    );\n  }\n}\n\nfunction BoardRow(props) {\n  const row = props.cells.map( (cell) =>\n    <BoardCell\n      key={cell.id}\n      id={cell.id}\n      block={cell.val}\n      onClickFunc={props.onClickFunc}\n      onDropFunc={props.onDropFunc}\n      winningRow={props.winningRow}\n      winningCol={props.winningCol}\n    />\n  );\n  return (\n    <div className=\"row boardrow p-0 m-0\">\n      {row}\n    </div>\n  );\n\n}\n\nclass Board extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      blocks: this.props.blocks,\n      blocksAdded: false,\n    };\n\n    this.onDrop = this.onDrop.bind(this);\n  }\n\n  // Function passed to the BoardCell component which will pass the rowPos and\n  // colPos information from the BoardCell where a DraggableBlock is dropped.\n  // This function uses that information and the DraggableBlock's numRows and\n  // numCols properties send from the Content component through the dragBlock\n  // property.\n  onDrop(e) {\n    if (this.props.dragBlock) {\n      // instantiate new block\n      let newBlock = { \n        rowPos: parseInt(e.currentTarget.id.split(\",\")[0]), \n        colPos: parseInt(e.currentTarget.id.split(\",\")[1]), \n        numRows: this.props.dragBlock.numRows,\n        numCols: this.props.dragBlock.numCols\n      };\n      let lastRow = newBlock.rowPos + newBlock.numRows - 1; // newBlock's max row\n      let lastCol = newBlock.colPos + newBlock.numCols - 1; // newBlock's max column\n      // ensure four block is not in the winning position\n      if (\n        newBlock.numRows*newBlock.numCols === 4 && \n        newBlock.rowPos === this.props.winningRow && \n        newBlock.colPos === this.props.winningCol\n      ) {\n        alert(\"The block of size 4 cannot be placed in the winning position\");\n      // ensure block does not fall off board\n      } else if(lastRow > 4 || lastCol > 3) {\n        alert(\"Invalid block placement\");\n      // ensure block of size 4 is not on the winning row\n      } else {\n        let newBlocks = this.state.blocks;\n        newBlocks.push(newBlock);\n        // push new block\n        this.setState(state => ({\n          blocksAdded: true,\n          blocks: newBlocks\n        }));\n        this.props.onAddBlock(this.state.blocks);\n      }\n    }\n  }\n\n  // function for displaying current board blocks\n  getBlocks(blocks) {\n    // maintain sync between the current blocks in the Board component's state\n    // and the blocks passed in by the Content component\n    if (blocks !== this.state.blocks) {\n      this.setState(state => ({\n        blocks: blocks\n      }));\n    }\n    const NoBlock = {\n      numRows: 0,\n      numCols: 0\n    };\n    // initialize 2d array with no blocks\n    var board = new Array(5);\n    for (var i = 0; i < 5; i++) {\n      var tempRow = {\n        id: i,\n        row: new Array(4)\n      }\n      for (var j = 0; j < 4; j++) {\n        var tempCell = {\n          id: i.toString() + \",\" + j.toString(), \n          val: {\n            numRows: 0,\n            numCols: 0,\n            rowPos: i,\n            colPos: j,\n          }\n        }\n        tempRow.row[j] = tempCell;\n      }\n      board[i] = tempRow;\n    }\n    // insert blocks\n    for (var b = 0; b < blocks.length; b++) {\n      var block = blocks[b];\n      let lastRow = block.rowPos + block.numRows - 1;\n      let lastCol = block.colPos + block.numCols - 1;      \n      for (var r = block.rowPos; r <= lastRow; r++) {\n        for (var c = block.colPos; c <= lastCol; c++) {\n          if (r === block.rowPos && c === block.colPos) {\n            ((board[r].row)[c]).val = block;\n          } else if (r === block.rowPos){\n            ((board[r].row)[c]).val = null;\n          } else {\n            ((board[r].row)[c]).val = NoBlock;\n          }\n        }\n      }\n    }\n    return board;\n  }\n\n  render() { \n    const rows = this.getBlocks(this.props.blocks);\n    const board = rows.map( (row) =>\n      <BoardRow\n        key={row.id}\n        cells={row.row}\n        onClickFunc={this.props.onClickFunc}\n        onDropFunc={this.onDrop}\n        winningRow={this.props.winningRow}\n        winningCol={this.props.winningCol}\n      />\n    )\n    return ( \n      <div className=\"p-0 mt-4 border\" id=\"board\">\n        {board}   \n      </div>\n    );\n  }\n}\n\nclass DraggableBlock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      rel: null,\n      pos: { left: 0, top: 0}\n    };\n    this.click = this.click.bind(this);\n    this.move = this.move.bind(this);\n    this.drop = this.drop.bind(this);\n  }\n\n  // function called on mouse down on a draggable block\n  click(e) {\n    if (e.button !== 0) return\n    let currPos = e.currentTarget.getBoundingClientRect();\n    this.setState((state) => ({\n      rel: {\n        left: currPos.left,\n        top: currPos.top\n      }\n    }));\n    document.addEventListener(\"mousemove\", this.move); // listen for mouse move\n    document.addEventListener(\"mouseup\", this.drop); // listen for mouse up (drop)\n    this.props.onDragFunc(e.currentTarget.id); // send content the current block's ID\n    e.stopPropagation();\n    e.preventDefault();\n  }\n  \n  // function called on mouse move after mouse down on a draggable block\n  move(e) {\n    let x = e.pageX;\n    let y = e.pageY;\n    this.setState((state) => ({\n      pos: {\n        left: x - this.state.rel.left,\n        top: y - this.state.rel.top\n      }\n    }));\n    e.stopPropagation();\n    e.preventDefault();\n  }\n\n  // function called on mouse up after mouse down on a draggable block\n  drop(e) {\n    this.setState((state) => ({\n      rel: null,\n      pos: {left: 0, top: 0}\n    }));\n    document.removeEventListener(\"mousemove\", this.move);\n    document.removeEventListener(\"mouseup\", this.drop);\n    e.stopPropagation();\n    e.preventDefault();\n  }\n\n  render() {\n    // dragblock vars\n    const steez = {\n      position: \"relative\",\n      left: this.state.pos.left + \"px\",\n      top: this.state.pos.top + \"px\"\n    };\n    const oneblockString  = \"draggable-oneblock  m-2 p-0 bg-success border border-dark rounded\";\n    const twoblockHString = \"draggable-twoblockH m-2 p-0 bg-warning border border-dark rounded\";\n    const twoblockVString = \"draggable-twoblockV m-2 p-0 bg-primary border border-dark rounded\";\n    const fourblockString = \"draggable-fourblock m-2 p-0 bg-danger  border border-dark rounded\";\n    let classString = \"\";\n    // check block size\n    if (this.props.size === 4) classString = fourblockString;\n    else if (this.props.size === 2 && this.props.block.numCols === 1) classString = twoblockVString;\n    else if (this.props.size === 2) classString = twoblockHString;\n    else if (this.props.size === 1) classString = oneblockString;\n    else alert(\"Invalid draggable block properties\");\n    // return dragblock\n    return (\n      <div className={classString}\n        id={this.props.id}\n        style={steez}\n        onMouseDown={this.click}>\n      </div>\n    );\n  }\n}\n\nfunction Toolbar(props) {\n  // only show toolbar when board is cleared or blocks are being added\n  if (props.show) {\n    return (\n      <div className=\"col-12 mt-2\">\n        <div className=\"row justify-content-center\">\n          <DraggableBlock \n            size={4} \n            id=\"2,2\"\n            onDragFunc={props.onDragFunc}\n          />\n          <DraggableBlock \n            size={2} \n            id=\"2,1\" \n            block={{ numRows: 2, numCols: 1 }} \n            onDragFunc={props.onDragFunc}\n          />\n          <DraggableBlock \n            size={2} \n            id=\"1,2\" \n            block={{ numRows: 1, numCols: 2 }} \n            onDragFunc={props.onDragFunc}\n          />\n          <DraggableBlock \n            size={1} \n            id=\"1,1\" \n            onDragFunc={props.onDragFunc}\n          />\n        </div>\n      </div>\n    );\n  } else {\n    return <span></span>;\n  }\n}\n\nfunction Buttons(props) {\n  // button for clearing board\n  const clearButton = (\n    <button className=\"btn btn-sm btn-danger mr-2\" \n      onClick={props.onClear}>\n        Clear\n    </button>\n  );\n  // button for clearing a user made board\n  const doubleClearButton = (\n    <button className=\"btn btn-sm btn-danger mr-2\" \n      onClick={props.onDoubleClear}>\n        Clear\n    </button>\n  );\n  // button for displaying the default board\n  const defaultButton = (\n    <button className=\"btn btn-sm btn-warning mx-1\" \n      onClick={props.onDefault}>\n        Default\n    </button>\n  );\n  // button to finalize moves in solution\n  const finishButton = (\n    <button className=\"btn btn-sm btn-success ml-2\" \n      onClick={props.onFinish}>\n        Finish\n    </button>\n  );\n  //button to see next move in solution\n  const nextButton = (\n    <button className=\"btn btn-sm btn-warning mx-2\" \n      onClick={props.onNext}>\n        Next\n    </button>\n  );\n  // button to see previous move in solution\n  const prevButton = (\n    <button className=\"btn btn-sm btn-danger mr-2\" \n      onClick={props.onPrev}\n      id=\"prev-btn\">\n        Prev\n    </button>\n  );\n  // button for running script to solve board\n  const solveButton = (\n    <button className=\"btn btn-sm btn-primary ml-2\" \n      onClick={props.onSolve}>\n        Solve!\n    </button>\n  );\n  \n  // buttons displayed after last solution move is seen \n  if (props.finished) {\n    return <span></span>;\n  // buttons displayed after solve button is pressed\n  } else if (props.solved) {\n    return (\n      <div className=\"text-center mt-2\">\n        {prevButton}\n        {nextButton}\n        {finishButton}\n      </div>\n    );\n  // buttons displayed after blocks have been dropped\n  } else if (props.blocksAdded){\n    return (\n      <div className=\"text-center mt-2\">\n        {doubleClearButton}\n        {solveButton}\n      </div>\n    );\n  // buttons displayed when board is cleared of blocks\n  } else if (props.cleared){\n    return (\n      <div className=\"text-center mt-2\">\n        {defaultButton}\n        {solveButton}\n      </div>\n    );\n  // buttons displayed when default board is shown\n  } else {\n    return (\n      <div className=\"text-center mt-2\">\n        {clearButton}\n        {solveButton}\n      </div>\n    );\n  }\n}\n\nclass Content extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      blocks: [],\n      blocksAdded: false,\n      cleared: true,\n      default: false,\n      displayText: \"Klotski Solver\",\n      dragBlock: null,\n      finished: false,\n      solved: false,\n      winningRow: 3,\n      winningCol: 1\n    };\n\n    this.blocksAdded = this.blocksAdded.bind(this);\n    this.clear = this.clear.bind(this);\n    this.clearDragBlock = this.clearDragBlock.bind(this);\n    this.default = this.default.bind(this);\n    this.doubleClear = this.doubleClear.bind(this);\n    this.dragBlockInfo = this.dragBlockInfo.bind(this);\n    this.finish = this.finish.bind(this);\n    this.next = this.next.bind(this);\n    this.prev = this.prev.bind(this);\n    this.restart = this.restart.bind(this);\n    this.setWinningPos = this.setWinningPos.bind(this);\n    this.solve = this.solve.bind(this);\n  }\n\n  // Function passed to the Board component that updates the Content\n  // blocksAdded state property when a user adds a block to the board.\n  blocksAdded(blocks) {\n    this.setState(state => ({\n      blocks: blocks,\n      blocksAdded: true,\n      cleared: false,\n    }))\n  }\n\n  // Function passed to the Buttons component that updates the Content\n  // cleared state property when a user clicks the clear button.\n  clear() {\n    this.setState(state => ({\n      blocks: [],\n      blocksAdded: false,\n      cleared: true,\n      default: false,\n      displayText: \"Klotski Solver\",\n      solved: false,\n      finished: false,\n      dragBlock: null,\n      winningRow: 3,\n      winningCol: 1\n    }));\n  }\n\n  // Function passed to the Buttons component that calls `clear()` and \n  // updates the Content doubleCleared state state property when a user \n  // clicks the doubleClear button.\n  doubleClear() {\n    this.clear();\n  }\n\n  restart() {\n    let clearFunc = this.clear;\n    setTimeout(\n      function () {clearFunc()},\n      3000\n    );\n  }\n\n  // Function passed to the Buttons component that updates the Content\n  // solved state property when a user clicks the solve button.\n  solve() {\n    try {\n      var s = new Solver(\n        this.state.blocks, \n        this.state.winningRow, \n        this.state.winningCol\n      );\n      s.solve();\n      let solutionMoves = s.getBoards();\n      const numMoves = solutionMoves.length;\n      if (numMoves === 0) {\n        this.setState(state => ({\n          displayText: \"No Solution Found :(\"\n        }));\n        this.restart();\n      } else {\n        this.setState(state => ({\n          blocksAdded: false,\n          default: false,\n          displayText: \"Solution of Length \" + numMoves.toString() + \" Found!\",\n          boards: solutionMoves,\n          boardIdx: -1,\n          solved: true\n        }));\n      }\n    } catch (err) {\n      alert(err);\n    }\n  }\n\n  // Function passed to the Buttons component that updates the Content\n  // boards and blocks state properties when a user clicks the next button.\n  next() {\n    if (this.state.boards.length === 0) {\n      return;\n    } else {\n      if (this.state.boardIdx === this.state.boards.length-1) {\n        this.setState(state => ({\n          solved: false,\n          finished: true,\n          displayText: \"You Win!\"\n        }));\n        this.restart();    \n      } else {\n        this.setState(state => ({\n          blocks: this.state.boards[this.state.boardIdx + 1],\n          boardIdx: this.state.boardIdx + 1,\n          displayText: \"Move \" + (this.state.boardIdx+2).toString()\n        }));\n      }\n    }\n  }\n\n  // Function passed to the Buttons component that updates the Content\n  // boards and blocks state properties when a user clicks the prev button.\n  prev() {\n     if (this.state.boards.length === 0) {\n      return;\n    } else {\n      if (this.state.boardIdx === -1) {\n        return;\n      } else {\n        this.setState(state => ({\n          blocks: this.state.boards[this.state.boardIdx - 1],\n          boardIdx: this.state.boardIdx - 1,\n          displayText: (this.state.boardIdx <= 0 ? \"Klotski Solver\" : \"Move \" + this.state.boardIdx.toString())\n        }));\n      }\n    }\n  }\n\n  // Function passed to the Buttons component that updates the Content\n  // boards and blocks state properties when a user clicks the next button.\n  finish() {\n    this.setState(state => ({ \n      solved: false,\n      finished: true \n    }));\n    let i = this.state.boardIdx;\n    let n = this.state.boards.length;\n    let callFunction = this.next;\n    // repeat calls to next with a .5 second interval\n    var repeater = setInterval(function () {\n      if (i < n) {\n        callFunction();\n        i++;\n      } else {\n        clearInterval(repeater);\n      }\n    }, 250);\n  }\n\n\n  // Function passed to the Buttons component that updates the Content\n  // default state property when a user clicks the default button.\n  default() {\n    const initialBlocks = [\n      { rowPos: 0, colPos: 0, numRows: 2, numCols: 1 },\n      { rowPos: 0, colPos: 1, numRows: 2, numCols: 2 },\n      { rowPos: 0, colPos: 3, numRows: 2, numCols: 1 },\n      { rowPos: 2, colPos: 0, numRows: 2, numCols: 1 },\n      { rowPos: 2, colPos: 1, numRows: 1, numCols: 2 },\n      { rowPos: 2, colPos: 3, numRows: 2, numCols: 1 },\n      { rowPos: 3, colPos: 1, numRows: 1, numCols: 1 },\n      { rowPos: 3, colPos: 2, numRows: 1, numCols: 1 },\n      { rowPos: 4, colPos: 0, numRows: 1, numCols: 1 },\n      { rowPos: 4, colPos: 3, numRows: 1, numCols: 1 }\n    ]\n    this.setState(state => ({\n      blocks: initialBlocks,\n      blocksAdded: false,\n      cleared: false,\n      default: true,\n      winningRow: 3,\n      winningCol: 1\n    }));\n  }\n\n  // Function passed to the Toolbar component (onDragFunc) which alerts the Content\n  // component when a DraggableBlock is being dragged and send the block's \n  // corresponding ID which contains the block's numRows and numCols properties.\n  // This information is used to update the Content dragBlock state property, which\n  // is passed to the Board component.\n  dragBlockInfo(id) {\n    this.setState(state => ({\n      dragBlock: {\n        numRows: parseInt(id.split(\",\")[0]),\n        numCols: parseInt(id.split(\",\")[1])\n      }\n    }));\n  } \n\n  setWinningPos(id) {\n    if (this.state.cleared) {\n      this.setState(state => ({\n        winningRow: parseInt(id.split(\",\")[0]),\n        winningCol: parseInt(id.split(\",\")[1])\n      }));\n    }\n  }\n\n  // Function passed to the Board component on mouse down, which is used to nullify\n  // the Content dragBlock state property.\n  clearDragBlock(e) {\n    this.setState(state => ({\n      dragBlock: null\n    }));\n  }\n\n  render() {\n    return (\n      <div id=\"content-wrapper\">\n        <div className=\"h1 text-center mt-1 mb-0\" id=\"header\">\n          {this.state.displayText} \n        </div>\n        <div className=\"row justify-content-center px-0 mx-0\"\n          onMouseDown={this.clearDragBlock}>\n          <div className=\"col-3 board\">\n            <Board \n              blocks={this.state.blocks}\n              dragBlock={this.state.dragBlock}\n              onAddBlock={this.blocksAdded}\n              onClickFunc={this.setWinningPos}\n              winningRow={this.state.winningRow}\n              winningCol={this.state.winningCol}\n            />\n            <Buttons \n              blocksAdded={this.state.blocksAdded}\n              cleared={this.state.cleared}\n              finished={this.state.finished}\n              solved={this.state.solved}\n              onClear={this.clear}\n              onDefault={this.default}\n              onDoubleClear={this.doubleClear}\n              onFinish={this.finish}\n              onNext={this.next}\n              onPrev={this.prev}\n              onSolve={this.solve}\n            />\n          </div>\n          <Toolbar \n            show={this.state.cleared || this.state.blocksAdded}\n            onDragFunc={this.dragBlockInfo}\n          />\n        </div>\n        <div className=\"text-center text-secondary\" id=\"footer\">\n          Developed by Sam Royall\n        </div>\n      </div>\n    );   \n  }\n}\n\nfunction App() {\n  return (\n    <Content />   \n  );\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}